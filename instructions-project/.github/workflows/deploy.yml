name: Deploy Instructions Project - Git Pull Direct

# Workflow atualizado: usa git pull diretamente (sem rsync) para deploy mais r√°pido e fi√°vel
# Vers√£o: 2.0 - Deploy direto via SSH sem rsync
# Este workflow N√ÉO usa rsync - apenas git pull direto no servidor
# NOTA: Para deploy mais seguro, usar deploy-safe.yml que tem timeouts e limita√ß√µes de concorr√™ncia
on:
  push:
    branches: [ master, main ]
  workflow_dispatch: {}

# Limitar a apenas 1 deploy por vez para evitar sobrecarga
concurrency:
  group: deploy-instructions
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 10  # Timeout total de 10 minutos
    
    steps:
      - name: Deploy via SSH (Git Pull)
        uses: appleboy/ssh-action@v1.2.0
        env:
          NODE_ENV: ${{ secrets.NODE_ENV }}
          PM2_NAME: ${{ secrets.PM2_NAME }}
          PORT: ${{ secrets.PORT }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          command_timeout: 8m  # Timeout de 8 minutos por comando SSH
          envs: NODE_ENV,PM2_NAME,PORT
          script: |
            # Definir diret√≥rios do projeto
            PROJECT_ROOT="/home/andre/apps/instructions/instructions-project"
            SERVER_DIR="${PROJECT_ROOT}/server"
            CLIENT_DIR="${PROJECT_ROOT}/client"
            
            echo "üöÄ Iniciando deploy do Instructions Project..."
            echo ""
            
            # 1. Garantir que Docker Compose est√° a correr
            echo "üê≥ [1/6] Verificando Docker Compose (PostgreSQL)..."
            cd "${PROJECT_ROOT}"
            if command -v docker-compose &> /dev/null; then
              docker-compose -f docker-compose.prod.yml up -d || docker-compose -f docker-compose.dev.yml up -d
            elif command -v docker &> /dev/null && docker compose version &> /dev/null; then
              docker compose -f docker-compose.prod.yml up -d || docker compose -f docker-compose.dev.yml up -d
            fi
            echo "‚úÖ PostgreSQL verificado/iniciado"
            echo ""
            
            # 2. Atualizar c√≥digo via git pull
            echo "üì• [2/6] Atualizando c√≥digo via git pull..."
            cd "${PROJECT_ROOT}"
            if [ -d .git ]; then
              git fetch origin
              CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
              if [ "$CURRENT_BRANCH" = "master" ] || [ "$CURRENT_BRANCH" = "main" ]; then
                git reset --hard origin/${CURRENT_BRANCH}
              else
                git reset --hard origin/master 2>/dev/null || git reset --hard origin/main 2>/dev/null
              fi
              echo "‚úÖ C√≥digo atualizado da branch ${CURRENT_BRANCH}"
            else
              echo "‚ùå Diret√≥rio .git n√£o encontrado!"
              echo "‚ö†Ô∏è Execute manualmente: git clone <repo-url> ${PROJECT_ROOT}"
              exit 1
            fi
            echo ""
            
            # 3. Atualizar .env do servidor
            echo "üîß [3/6] Configurando vari√°veis de ambiente..."
            cd "${SERVER_DIR}"
            if [ -f .env ]; then
              # Garantir DB_HOST=localhost
              if grep -q "^DB_HOST=" .env; then
                sed -i 's|^DB_HOST=.*$|DB_HOST=localhost|' .env
              else
                echo "DB_HOST=localhost" >> .env
              fi
              
              # Atualizar PORT
              PORT_FINAL="${PORT:-5000}"
              if grep -q "^PORT=" .env; then
                sed -i "s|^PORT=.*$|PORT=${PORT_FINAL}|" .env
              else
                echo "PORT=${PORT_FINAL}" >> .env
              fi
              
              # Atualizar NODE_ENV
              NODE_ENV_FINAL="${NODE_ENV:-production}"
              if grep -q "^NODE_ENV=" .env; then
                sed -i "s|^NODE_ENV=.*$|NODE_ENV=${NODE_ENV_FINAL}|" .env
              else
                echo "NODE_ENV=${NODE_ENV_FINAL}" >> .env
              fi
              
              echo "‚úÖ .env atualizado"
            else
              echo "‚ö†Ô∏è Ficheiro .env n√£o encontrado, criando..."
              echo "DB_HOST=localhost" > .env
              echo "DB_PORT=5433" >> .env
              echo "DB_NAME=instructions_demo" >> .env
              echo "DB_USER=demo_user" >> .env
              echo "DB_PASSWORD=demo_password" >> .env
              echo "PORT=${PORT:-5000}" >> .env
              echo "NODE_ENV=${NODE_ENV:-production}" >> .env
              echo "‚úÖ .env criado"
            fi
            echo ""
            
            # 4. Instalar depend√™ncias do servidor (com timeout)
            echo "üì¶ [4/6] Instalando depend√™ncias do servidor..."
            cd "${SERVER_DIR}"
            if [ -f package-lock.json ]; then
              timeout 180 npm ci --omit=dev --maxsockets=1 || timeout 180 npm install --omit=dev --maxsockets=1
            else
              timeout 180 npm install --omit=dev --maxsockets=1
            fi
            echo "‚úÖ Depend√™ncias do servidor instaladas"
            echo ""
            
            # 5. Build do cliente (com timeout e limite de mem√≥ria)
            echo "üèóÔ∏è  [5/6] Fazendo build do cliente..."
            cd "${CLIENT_DIR}"
            if [ -f package-lock.json ]; then
              timeout 180 npm ci --maxsockets=1 || timeout 180 npm install --maxsockets=1
            else
              timeout 180 npm install --maxsockets=1
            fi
            NODE_OPTIONS="--max-old-space-size=2048" timeout 300 npm run build
            echo "‚úÖ Cliente compilado"
            echo ""
            
            # 6. Reiniciar PM2
            echo "üîÑ [6/6] Reiniciando servidor com PM2..."
            PM2_NAME_FINAL="${PM2_NAME:-instructions-server}"
            pm2 delete ${PM2_NAME_FINAL} 2>/dev/null || true
            cd "${SERVER_DIR}"
            pm2 start npm --name ${PM2_NAME_FINAL} -- start
            pm2 save
            echo ""
            
            # Aguardar servidor iniciar
            echo "‚è≥ Aguardando servidor iniciar..."
            sleep 5
            
            # Verificar se servidor est√° online
            if curl -f -s http://localhost:5000/health > /dev/null 2>&1; then
              echo "‚úÖ Servidor online e respondendo!"
            else
              echo "‚ö†Ô∏è Servidor pode n√£o estar totalmente pronto ainda"
            fi
            echo ""
            
            # Verificar status final
            echo "üìä Status final:"
            pm2 status
            echo ""
            echo "‚úÖ Deploy conclu√≠do com sucesso!"
            echo "üåê Servidor dispon√≠vel em: https://136.116.79.244"

